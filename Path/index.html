<html>
    <head>
        <title>Path Planning</title>
        <link rel="stylesheet" type="text/css" href="main.css">
        <script src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
        <script type="text/javascript">
            var ctx;
            var environment;
        	var WIDTH;
            var HEIGHT;
            var tileSize = 0;
            var mouseClicks = 0;
            var inits = 0;
            var start;
            var end;
            var play = true;
            var stepF = false;
            var stepB = false;
            var fontSize = 0;
            var canGo = false;
            var path;
            var interval;
            var inter2;
            var inter3;
            var inter4;
            var gameify = false;
            
            var paths = {
            	search: function(algorithm, heuristic, start, end) {
             		var openList = [];
            		var closedList = [];
            		openList.push(start);
            		while(openList.length > 0) {
            			var lowest = 0;
            			for(var i = 0; i < openList.length; i++) {
            				if(openList[i].f < openList[lowest].f)
                                lowest = i;
            			}
            			var currentNode = openList[lowest];
             
            			if(currentNode.x == end.x && currentNode.y == end.y) {
            				var curr = currentNode;
            				var result = [];
            				while(curr.parent) {
            					result.push(curr);
            					curr = curr.parent;
            				}
            				return result.reverse();
            			}
             
                        var index = openList.indexOf(currentNode);
                        if (index > -1) {
                            openList.splice(index, 1);
                        }
            			closedList.push(currentNode);
            			var neighbors = paths.neighbors(currentNode);
             
            			for(var i = 0; i < neighbors.length; i++) {
            				var neighbor = neighbors[i];
                            var inClosedList = false;
                            for(var j = 0; j < closedList.length; j++) {
                                if(neighbor == closedList[j])
                                    inClosedList = true;
                            }
            				if(inClosedList || neighbor.isWall) {
            					continue;
            				}
                            if(algorithm == "Dijkstra") {
                				var currF = currentNode.f + 10;
                				var bestF = false;
                 
                                var inOpenList = false;
                                for(var j = 0; j < openList.length; j++) {
                                    if(neighbor == openList[j])
                                        inOpenList = true;
                                }
                                
                				if(!inOpenList) {
                					bestF = true;
                                    if(heuristic == "Manhattan")
                				        neighbor.h = paths.manhattan(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                    else if(heuristic == "Euclidean")
                                        neighbor.h = paths.euclidean(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                    else if(heuristic == "Diagonal")
                                        neighbor.h = paths.diagonal(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                					openList.push(neighbor);
                				}
                				else if(currF < neighbor.f) {
                					bestF = true;
                				}
                 
                				if(bestF) {
                					neighbor.parent = currentNode;
                					neighbor.f = currF;
                                    if(heuristic == "Manhattan")
                                        neighbor.g = paths.manhattan(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                    else if(heuristic == "Euclidean")
                                       neighbor.g = paths.euclidean(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                    else if(heuristic == "Diagonal")
                                       neighbor.g = paths.diagonal(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                				}
                            } else if(algorithm == "A Star") {
                                var currG = currentNode.g + 10;
                                var bestG = false;
                 
                                var inOpenList = false;
                                for(var j = 0; j < openList.length; j++) {
                                    if(neighbor == openList[j])
                                        inOpenList = true;
                                }
                                
                                if(!inOpenList) {
                                    bestG = true;
                                    if(heuristic == "Manhattan")
                                        neighbor.h = paths.manhattan(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                    else if(heuristic == "Euclidean")
                                            neighbor.h = paths.euclidean(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                    else if(heuristic == "Diagonal")
                                            neighbor.h = paths.diagonal(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                    openList.push(neighbor);
                                }
                                else if(currG < neighbor.g) {
                                    bestG = true;
                                }
                 
                                if(bestG) {
                                    neighbor.parent = currentNode;
                                    neighbor.g = currG;
                                    neighbor.f = neighbor.g + neighbor.h;
                                }
                            } else if(algorithm == "Best First") {
                                var currH = currentNode.h + 10;
                                var bestH = false;
                 
                                var inOpenList = false;
                                for(var j = 0; j < openList.length; j++) {
                                    if(neighbor == openList[j])
                                        inOpenList = true;
                                }
                                
                                if(!inOpenList) {
                                    bestH = true;
                                    if(heuristic == "Manhattan")
                                        neighbor.g = paths.manhattan(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                    else if(heuristic == "Euclidean")
                                        neighbor.g = paths.euclidean(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                    else if(heuristic == "Diagonal")
                                        neighbor.g = paths.diagonal(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                    openList.push(neighbor);
                                }
                                else if(currH < neighbor.h) {
                                    bestH = true;
                                }
                 
                                if(bestH) {
                                    neighbor.parent = currentNode;
                                    if(heuristic == "Manhattan")
                                       neighbor.h = paths.manhattan(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                    else if(heuristic == "Euclidean")
                                       neighbor.h = paths.euclidean(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                    else if(heuristic == "Diagonal")
                                       neighbor.h = paths.diagonal(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                    neighbor.f = neighbor.g + neighbor.h;
                                }
                            }
            			}
            		}
                    //No suitable path
            		return [];
            	},
                step: function(algorithm, heuristic, start, end) {
                    //This is what shows the animations
                    var openList = [];
                    var closedList = [];
                    openList.push(start);
                    interval = setInterval(function() {
                        if(play || stepF) {
                            var lowest = 0;
                            for(var i = 0; i < openList.length; i++) {
                                if(openList[i].f < openList[lowest].f)
                                    lowest = i;
                            }
                            var currentNode = openList[lowest];
                 
                            if(currentNode.x == end.x && currentNode.y == end.y) {
                                var curr = currentNode;
                                var result = [];
                                while(curr.parent) {
                                    result.push(curr);
                                    curr = curr.parent;
                                }
                                for(var counter = 0; counter < result.length; counter++) {
                                    stroke(result[counter].x, result[counter].y, "yellow");
                                }
                                clearInterval(interval);
                                if(gameify) {
                                    var counter = 0;
                                    inter3 = setInterval(function () {
                                        drawPic("player", result[counter].x, result[counter].y, tileSize);
                                        if(counter == 0)
                                            drawPic("floor", start.x, start.y, tileSize);
                                        else
                                            drawPic("floor", result[counter-1].x, result[counter-1].y, tileSize);
                                        if(result[counter].x == end.x && result[counter].y == end.y)
                                            clearInterval(inter3);
                                        counter ++;
                                    }, $("#slider").val());
                                }
                                return result.reverse();
                            }
                 
                            var index = openList.indexOf(currentNode);
                            if (index > -1) {
                                openList.splice(index, 1);
                            }
                            closedList.push(currentNode);
                            var neighbors = paths.neighbors(currentNode);
                 
                            for(var i = 0; i < neighbors.length; i++) {
                                var neighbor = neighbors[i];
                                var inClosedList = false;
                                for(var j = 0; j < closedList.length; j++) {
                                    if(neighbor == closedList[j])
                                        inClosedList = true;
                                }
                                if(inClosedList || neighbor.isWall) {
                                    continue;
                                }
                                if(algorithm == "Dijkstra") {
                                    var currF = currentNode.f + 10;
                                    var bestF = false;
                     
                                    var inOpenList = false;
                                    for(var j = 0; j < openList.length; j++) {
                                        if(neighbor == openList[j])
                                            inOpenList = true;
                                    }
                                    
                                    if(!inOpenList) {
                                        bestF = true;
                                        if(heuristic == "Manhattan")
                                           neighbor.h = paths.manhattan(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                        else if(heuristic == "Euclidean")
                                            neighbor.h = paths.euclidean(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                        else if(heuristic == "Diagonal")
                                            neighbor.h = paths.diagonal(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                        drawText(neighbor.h, neighbor.x + (.85*tileSize), neighbor.y + fontSize);
                                        openList.push(neighbor);
                                    }
                                    else if(currF < neighbor.f) {
                                        bestF = true;
                                    }
                     
                                    if(bestF) {
                                        neighbor.parent = currentNode;
                                        neighbor.f = currF;
                                        if(heuristic == "Manhattan")
                                           neighbor.g = paths.manhattan(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                        else if(heuristic == "Euclidean")
                                           neighbor.g = paths.euclidean(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                        else if(heuristic == "Diagonal")
                                           neighbor.g = paths.diagonal(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                        drawText(neighbor.g, neighbor.x, neighbor.y + fontSize);
                                        drawText(neighbor.g + neighbor.h, neighbor.x + tileSize/2 - fontSize/2, neighbor.y + fontSize + tileSize/2 - fontSize/2);
                                        stroke(neighbor.x, neighbor.y, "teal");
                                    }
                                } else if(algorithm == "A Star") {
                                    var currG = currentNode.g + 10;
                                    var bestG = false;
                     
                                    var inOpenList = false;
                                    for(var j = 0; j < openList.length; j++) {
                                        if(neighbor == openList[j])
                                            inOpenList = true;
                                    }
                                    
                                    if(!inOpenList) {
                                        bestG = true;
                                        if(heuristic == "Manhattan")
                                            neighbor.h = paths.manhattan(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                        else if(heuristic == "Euclidean")
                                                neighbor.h = paths.euclidean(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                        else if(heuristic == "Diagonal")
                                                neighbor.h = paths.diagonal(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                        drawText(neighbor.h, neighbor.x + (.85*tileSize), neighbor.y + fontSize);
                                        openList.push(neighbor);
                                    }
                                    else if(currG < neighbor.g) {
                                        bestG = true;
                                    }
                     
                                    if(bestG) {
                                        neighbor.parent = currentNode;
                                        if(heuristic == "Manhattan")
                                            neighbor.g = paths.manhattan(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                        else if(heuristic == "Euclidean")
                                            neighbor.g = paths.euclidean(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                        else if(heuristic == "Diagonal")
                                            neighbor.g = paths.diagonal(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                        drawText(neighbor.g, neighbor.x, neighbor.y + fontSize);
                                        neighbor.f = neighbor.g + neighbor.h;
                                        drawText(neighbor.g + neighbor.h, neighbor.x + tileSize/2 - fontSize/2, neighbor.y + fontSize + tileSize/2 - fontSize/2);
                                        stroke(neighbor.x, neighbor.y, "teal");
                                    }
                                } else if(algorithm == "Best First") {
                                    var currH = currentNode.h + 10;
                                    var bestH = false;
                     
                                    var inOpenList = false;
                                    for(var j = 0; j < openList.length; j++) {
                                        if(neighbor == openList[j])
                                            inOpenList = true;
                                    }
                                    
                                    if(!inOpenList) {
                                        bestH = true;
                                        if(heuristic == "Manhattan")
                                            neighbor.g = paths.manhattan(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                        else if(heuristic == "Euclidean")
                                            neighbor.g = paths.euclidean(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                        else if(heuristic == "Diagonal")
                                            neighbor.g = paths.diagonal(neighbor.indexX, neighbor.indexY, start.indexX, start.indexY) * 10;
                                        drawText(neighbor.g, neighbor.x, neighbor.y + fontSize);
                                        openList.push(neighbor);
                                    }
                                    else if(currH < neighbor.h) {
                                        bestH = true;
                                    }
                     
                                    if(bestH) {
                                        neighbor.parent = currentNode;
                                        if(heuristic == "Manhattan")
                                           neighbor.h = paths.manhattan(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                        else if(heuristic == "Euclidean")
                                           neighbor.h = paths.euclidean(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                        else if(heuristic == "Diagonal")
                                           neighbor.h = paths.diagonal(neighbor.indexX, neighbor.indexY, end.indexX, end.indexY) * 10;
                                        drawText(neighbor.h, neighbor.x + (.85*tileSize), neighbor.y + fontSize);
                                        neighbor.f = neighbor.g + neighbor.h;
                                        drawText(neighbor.g + neighbor.h, neighbor.x + tileSize/2 - fontSize/2, neighbor.y + fontSize + tileSize/2 - fontSize/2);
                                        stroke(neighbor.x, neighbor.y, "teal");
                                    }
                                }
                            }
                            if(openList.length <= 0) {
                                clearInterval(interval);
                            }
                            stepF = false;
                        } else if(stepB) {
                            if(openList[0] != null) {
                                var temp = openList.pop();
                                rect(temp.x, temp.y, "black");
                            }
                            stepB = false;
                        }
                    }, $("#slider").val());
                    //No suitable path
                    return [];
                },
            	manhattan: function(x1, y1, x2, y2) {
            		var d1 = Math.abs(x2 - x1);
            		var d2 = Math.abs(y2 - y1);
            		return d1 + d2;
            	},
                euclidean: function(x1, y1, x2, y2) {
                    var d1 = Math.abs(x2 - x1);
                    var d2 = Math.abs(y2 - y1);
                    return Math.round(Math.sqrt(Math.pow(d2, 2) + Math.pow(d1, 2)) * 10) / 10;
                },
                diagonal: function (x1, y1, x2, y2) {
                    var d1 = Math.abs(x2 - x1);
                    var d2 = Math.abs(y2 - y1);
                    return Math.round((d1 + d2) + (1.4 - 2) * Math.min(d1, d2));
                },
            	neighbors: function(node) {
            		var result = [];
            		var x = node.indexX;
            		var y = node.indexY;
            		if(environment[x - 1] && environment[x - 1][y]) {
            			result.push(environment[x - 1][y]);
            		}
            		if(environment[x + 1] && environment[x + 1][y]) {
            			result.push(environment[x + 1][y]);
            		}
            		if(environment[x][y - 1] && environment[x][y - 1]) {
            			result.push(environment[x][y - 1]);
            		}
            		if(environment[x][y + 1] && environment[x][y + 1]) {
            			result.push(environment[x][y + 1]);
            		}
            		return result;
            	}
            };

            //This is my custom searching algorithm (closest-best)
            path2 = {
                search: function(heuristic, start, end) {
                    var openList = [];
                    var best = [];
                    openList.push(start);
                    while(true) {
                        var temp = openList.pop();
                        var neighbors = path2.neighbors(temp);
                        neighbors = neighbors.filter(function(e) {
                            return e.isWall != true;
                        });
                        if(neighbors.length > 1) {
                            neighbors = neighbors.filter(function(e) {
                                return e.visitedTwice != true;
                            });
                        }
                        if(neighbors[0] == null) {
                            return [];
                        }
                        var bestNode = neighbors[0];
                        if(heuristic == "Euclidean")
                            var bestNodeCount = path2.euclidean(neighbors[0].indexX, neighbors[0].indexY, end.indexX, end.indexY);
                        else if(heuristic == "Manhattan")
                            var bestNodeCount = path2.manhattan(neighbors[0].indexX, neighbors[0].indexY, end.indexX, end.indexY);
                        else if(heuristic == "Diagonal")
                            var bestNodeCount = path2.diagonal(neighbors[0].indexX, neighbors[0].indexY, end.indexX, end.indexY);
                        for(var i = 1; i < neighbors.length; i++) {
                            if(heuristic == "Euclidean") {
                                if(path2.euclidean(neighbors[i].indexX, neighbors[i].indexY, end.indexX, end.indexY) < bestNodeCount) {
                                    bestNodeCount = path2.euclidean(neighbors[i].indexX, neighbors[i].indexY, end.indexX, end.indexY);
                                    bestNode = neighbors[i];
                                }
                            } else if(heuristic == "Manhattan") {
                                if(path2.manhattan(neighbors[i].indexX, neighbors[i].indexY, end.indexX, end.indexY) < bestNodeCount) {
                                    bestNodeCount = path2.manhattan(neighbors[i].indexX, neighbors[i].indexY, end.indexX, end.indexY);
                                    bestNode = neighbors[i];
                                }
                            } else if(heuristic == "Diagonal") {
                                if(path2.diagonal(neighbors[i].indexX, neighbors[i].indexY, end.indexX, end.indexY) < bestNodeCount) {
                                    bestNodeCount = path2.diagonal(neighbors[i].indexX, neighbors[i].indexY, end.indexX, end.indexY);
                                    bestNode = neighbors[i];
                                }
                            }
                        }
                        if(bestNode.visited)
                            bestNode.visitedTwice = true;
                        bestNode.visited = true;
                        if(heuristic == "Euclidean") {
                            bestNode.g = path2.euclidean(bestNode.indexX, bestNode.indexY, start.indexX, start.indexY) * 10;
                            bestNode.h = path2.euclidean(bestNode.indexX, bestNode.indexY, end.indexX, end.indexY) * 10;
                            bestNode.f = bestNode.g + bestNode.h;
                        } else if(heuristic == "Manhattan") {
                            bestNode.g = path2.manhattan(bestNode.indexX, bestNode.indexY, start.indexX, start.indexY) * 10;
                            bestNode.h = path2.manhattan(bestNode.indexX, bestNode.indexY, end.indexX, end.indexY) * 10;
                            bestNode.f = bestNode.g + bestNode.h;
                        } else if(heuristic == "Diagonal") {
                            bestNode.g = path2.diagonal(bestNode.indexX, bestNode.indexY, start.indexX, start.indexY) * 10;
                            bestNode.h = path2.diagonal(bestNode.indexX, bestNode.indexY, end.indexX, end.indexY) * 10;
                            bestNode.f = bestNode.g + bestNode.h;
                        }
                        best.push(bestNode);
                        openList.push(bestNode);
                        if(bestNode.indexX == end.indexX && bestNode.indexY == end.indexY) {
                            return best;
                        }
                    }
                },
                neighbors: function(node) {
                    var result = [];
                    var x = node.indexX;
                    var y = node.indexY;
                    if(environment[x - 1] && environment[x - 1][y]) {
                        result.push(environment[x - 1][y]);
                    }
                    if(environment[x + 1] && environment[x + 1][y]) {
                        result.push(environment[x + 1][y]);
                    }
                    if(environment[x][y - 1] && environment[x][y - 1]) {
                        result.push(environment[x][y - 1]);
                    }
                    if(environment[x][y + 1] && environment[x][y + 1]) {
                        result.push(environment[x][y + 1]);
                    }
                    return result;
                },
                manhattan: function(x1, y1, x2, y2) {
                    var d1 = Math.abs(x2 - x1);
                    var d2 = Math.abs(y2 - y1);
                    return d1 + d2;
                },
                euclidean: function(x1, y1, x2, y2) {
                    var d1 = Math.abs(x2 - x1);
                    var d2 = Math.abs(y2 - y1);
                    return Math.round(Math.sqrt(Math.pow(d2, 2) + Math.pow(d1, 2)) * 10) / 10;
                },
                diagonal: function (x1, y1, x2, y2) {
                    var d1 = Math.abs(x2 - x1);
                    var d2 = Math.abs(y2 - y1);
                    return Math.round((d1 + d2) + (1.4 - 2) * Math.min(d1, d2));
                }
            };
            //The node structure        
            function node() {
                this.f = 0;
                this.g = 0;
                this.h = 0;
                this.parent = null;
                this.val = 0;
                this.x = 0;
                this.y = 0;
                this.isWall = false;
                this.indexX = 0;
                this.indexY = 0;
                this.visited = false;
                this.visitedTwice = false;
            }

            function init() {
                gameify = false;
                if(inter3 != null)
                    clearInterval(inter3);
                if(inter4 != null)
                    clearInterval(inter4);
                if(interval != null)
                    clearInterval(interval);
                if(inter2 != null)
                    clearInterval(inter2);
                mouseClicks = 0;
                play = true;
                $("#playAndPause").html('Pause');
                $("#infoStart").slideDown();
                $("#infoEnd").slideDown();
                $("#theRest").slideDown();
                $("#results").slideUp();
                environment = getMap();
                //get largest side
                var curr = environment.length;
                for(var i = 0; i < environment.length; i++) {
                    if(environment[i].length > curr) {
                        curr = environment[i].length;
                    }
                }
                ctx = document.getElementById('canvas').getContext('2d');
                WIDTH = ctx.canvas.width;
                HEIGHT = ctx.canvas.height;
                tileSize = Math.round(WIDTH/curr) - 1;
                fontSize = Math.floor(tileSize/10);
                if(inits == 0) {
                    document.addEventListener("mousedown", function(e){
                        doAddEventListener(e);
                    });
                    document.addEventListener("touchend", function(e){
                        doAddEventListener(e);
                    });
                }
                inits++;
                draw();
            }
            
            //Creates mouse and touch events
            function doAddEventListener(e) {
                mouseX = e.pageX - ctx.canvas.getBoundingClientRect().left;
                mouseY = e.pageY - ctx.canvas.getBoundingClientRect().top;
                var canPut = true;
                var isValid = false;
                var envIndexX = 0;
                var envIndexY = 0;
                for(var i = 0; i < environment.length; i ++) {
                    for(var j = 0; j < environment[i].length; j++) {
                        if(environment[i][j].val == 1) {
                            if(mouseX > environment[i][j].x && mouseX < environment[i][j].x + tileSize && mouseY > environment[i][j].y && mouseY < environment[i][j].y + tileSize) {
                                canPut = false;
                                x = environment[i][j].x;
                                y = environment[i][j].y;
                                envIndexX = environment[i][j].indexX;
                                envIndexY = environment[i][j].indexY;
                            }
                        } else if(environment[i][j].val == 0) {
                            if(mouseX > environment[i][j].x && mouseX < environment[i][j].x + tileSize && mouseY > environment[i][j].y && mouseY < environment[i][j].y + tileSize) {
                                isValid = true;
                                x = environment[i][j].x;
                                y = environment[i][j].y;
                                envIndexX = environment[i][j].indexX;
                                envIndexY = environment[i][j].indexY;
                            }
                        }
                    }
                }
                if(canPut && isValid) {
                    if(mouseClicks == 0) {
                        $("#infoStart").slideUp();
                        rect(x, y, "green");
                        start = new node();
                        start.x = x;
                        start.y = y;
                        start.indexX = envIndexX;
                        start.indexY = envIndexY;
                    }
                    else if(mouseClicks == 1) {
                        $("#infoEnd").slideUp();
                        canGo = true;
                        rect(x, y, "red");
                        end = new node();
                        end.x = x;
                        end.y = y;
                        end.indexX = envIndexX;
                        end.indexY = envIndexY;
                    }
                    mouseClicks++;
                }
            }
            
            function beginpaths() {
                if(canGo) {
                    canGo = false;
                    var algorithm = $("#algorithm").val();
                    var heuristic = $("#heuristic").val();
                    $("#theRest").slideUp();
                    if(algorithm == "Custom") {
                        if(heuristic == "Manhattan") {
                            alert("Currenly, Manhattan heuristic does not work with Custom.");
                        } else {
                            path = path2.search(heuristic, start, end);
                            $("#results").slideDown();
                            if(path.length == 0) {
                                $("#numSteps").text("None");
                                $("#finalLength").text("None");
                            }
                            else {
                                $("#numSteps").text(path.length);
                                $("#finalLength").text(path.length * 10);
                            }                   
                            var counter = 0;
                            inter2 = setInterval(function() {
                                if(play || stepF) {
                                    if(path[0] != null) {
                                        stroke(path[counter].x, path[counter].y, "teal");
                                        drawText(path[counter].g, path[counter].x, path[counter].y + fontSize);
                                        drawText(path[counter].h, path[counter].x + (.85*tileSize), path[counter].y + fontSize);
                                        drawText(path[counter].f, path[counter].x + tileSize/2 - fontSize/2, path[counter].y + fontSize + tileSize/2 - fontSize/2);
                                        if(counter == path.length - 1) {
                                            clearInterval(inter2);
                                            for(var i = 0; i < path.length; i++) {
                                                stroke(path[i].x, path[i].y, "yellow");
                                            }
                                            if(gameify) {
                                                var counter2 = 0;
                                                inter4 = setInterval(function() {
                                                    drawPic("floor", start.x, start.y, tileSize);
                                                    if(counter2 > 0) {
                                                        drawPic("floor", path[counter2 - 1].x, path[counter2 - 1].y, tileSize);
                                                    }
                                                    drawPic("player", path[counter2].x, path[counter2].y, tileSize);
                                                    if(path[counter2].x == end.x && path[counter2].y == end.y)
                                                        clearInterval(inter4);
                                                    counter2++;
                                                }, $("#slider").val());
                                            }
                                        }
                                        counter++;
                                    } else {
                                        clearInterval(inter2);
                                        $("#numSteps").text("None");
                                        $("#finalLength").text("None");
                                    }
                                    stepF = false;
                                }
                            }, $("#slider").val());
                        }
                    } else {
                        path = paths.search(algorithm, heuristic, start, end);
                        $("#results").slideDown();
                        if(path.length == 0) {
                            $("#numSteps").text("None");
                            $("#finalLength").text("None");
                        }
                        else {
                            $("#numSteps").text(path.length);
                            $("#finalLength").text(path.length * 10);
                        }                   
                        paths.step(algorithm, heuristic, start, end);
                    }
                }
            }
            
            //gets the map from the textarea
            function getMap() {
                var temp = $("#environment").val()
                var array = [];
                var innerArray = [];
                for(var i = 0; i <= temp.length; i++) {
                    if(temp[i] == '\n' || i == temp.length) {
                        array.push(innerArray);
                        innerArray = [];
                    } else if(temp[i] == 'o') {
                        var temp2 = new node();
                        temp2.val = 1;
                        innerArray.push(temp2);
                    } else if(temp[i] == 'e') {
                        var temp2 = new node();
                        temp2.val = 0;
                        innerArray.push(temp2);
                    }
                }
                return array;
            }
            //clear screen
            function clear() {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
            }
            //draw square
            function rect(x,y, color) {
                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.rect(x,y, tileSize, tileSize);
                ctx.closePath();
                ctx.fill();
            }
            //stroke square
            function stroke(x, y, color) {
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.moveTo(x, y);
                ctx.lineTo(x + tileSize, y);
                ctx.moveTo(x + tileSize, y);
                ctx.lineTo(x + tileSize, y + tileSize);
                ctx.moveTo(x + tileSize, y + tileSize);
                ctx.lineTo(x, y + tileSize);
                ctx.moveTo(x, y + tileSize);
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.closePath();
            }
            //initially draws grid
            function draw() {
                clear();
                var x = 0;
                var y = 0;
                for(var i = 0; i < environment.length; i++) {
                    for(var j = 0; j < environment[i].length; j++) {
                        if(environment[i][j].val == 1) {
                            environment[i][j].x = j + x;
                            environment[i][j].y = i + y;
                            environment[i][j].isWall = true;
                            environment[i][j].indexX = i;
                            environment[i][j].indexY = j;
                            rect(j + x, i + y, "blue");
                        } else if(environment[i][j].val == 0) {
                            environment[i][j].x = j + x;
                            environment[i][j].y = i + y;
                            environment[i][j].indexX = i;
                            environment[i][j].indexY = j;
                            rect(j + x, i + y, "black");
                        }
                        x += tileSize;
                    }
                    x = 0;
                    y += tileSize;
                }
            }
            //draws text
            function drawText(text, x, y) {
                if(tileSize > 70 && !gameify) {
                    ctx.font = fontSize.toString() + "px Arial";
                    ctx.fillStyle = "white";
                    ctx.fillText(text,x,y);
                }
            }
            //generates random 100x100 grid
            function generate() {
                var temp = "";
                $("#slider").val(0);
                for(var i = 0; i < 100; i++) {
                    for(var j = 0; j < 100; j++) {
                        if(Math.floor((Math.random() * 10) + 1) < 3)
                            temp += "o";
                        else
                            temp += "e";
                    }
                    temp += "\n";
                }
                $("#environment").val(temp);
            }
            //handles the play/pause button
            function setPlay() {
                if($("#playAndPause").html() == "Pause") {
                    $("#playAndPause").html('&nbsp;Play&nbsp;&nbsp;');
                } else {
                    $("#playAndPause").html('Pause');
                }
                play = !play;
            }
            //handles stepping forward
            function stepForward() {
                stepF = true;
            }
            function stepBackward() {
                stepB = true;
            }
            //changes algorithm
            function handleChange() {
                if($("#algorithm").val() == "Custom") {
                    $("#heuristic").val("Euclidean");
                }
            }
            //sets grid to first defautl map
            function doDefault1() {
                $("#environment").val("eeeeeeee\neeeeoeee\neeeeoeee \neeeeoeee \neeeeeeee \neeeeeeee");
            }
            //sets grid to second defautl map
            function doDefault2() {
                $("#environment").val("eeeeeeee\neeeoeoee\neeeoeoee \neeeoooee \neeeeeeee \neeeeeeee");
            }
            //sets grid to third defautl map
            function doDefault3() {
                $("#environment").val("eeeeeeee\neeeeoeee\neeeeoeee\neeeeoeee\neeeeeeee\neeeeeeee\neeeeeeee\neeeeoeee\neeeeoeee\neeeeoeee\neeeeeeee\neeeeeeee\neeeeeeee\neeeeoeee\neeeeoeee\neeeeoeee\neeeeeeee\neeeeeeee\neeeeeeee\neeeeoeee\neeeeoeee\neeeeoeee\neeeeeeee\neeeeeeee");
            }
            //makes tiles look like game
            function setGameify() {
                if(canGo) {
                    if(tileSize > 20) {
                        gameify = true;
                        for(var i = 0; i < environment.length; i++) {
                            for(var j = 0; j < environment[i].length; j++) {
                                if(environment[i][j].isWall) {
                                    drawPic("tile", environment[i][j].x, environment[i][j].y, tileSize);
                                } else {
                                    drawPic("floor", environment[i][j].x, environment[i][j].y, tileSize);
                                }
                                if(environment[i][j].x == start.x && environment[i][j].y == start.y) {
                                    drawPic("player", environment[i][j].x, environment[i][j].y, tileSize);
                                } else if(environment[i][j].x == end.x && environment[i][j].y == end.y) {
                                    drawPic("princess", environment[i][j].x, environment[i][j].y, tileSize);
                                }
                            }
                        }
                    } else {
                        alert("Too small to Gameify!");
                    }
                }
            }
            //draws the game pictures
            function drawPic(name, x, y, tileSize) {
                var img = document.getElementById(name);
                ctx.drawImage(img,x,y,tileSize,tileSize);
            }
        </script>
    </head>
    <body>
        <canvas id="canvas" width="600" height="600" style="border-style: solid;">
        Your browser does not support the canvas element.
        </canvas>
        <div id="sidebar">
            <h2 style="margin:6;">Instructions</h2>
            <div style="border:solid;">
                <h3 id="gTitle">Environment</h3>
                <textarea id="environment" placeholder="Enter environment here..."></textarea>
                <div id="defaultButtons">
                    <button id="default1" onclick="doDefault1();">Default 1</button>
                    <button id="default1" onclick="doDefault2();">Default 2</button>
                    <button id="default1" onclick="doDefault3();">Default 3</button>
                    <button id="random" onclick="generate();">Random</button>
                </div>
                <br />
                <button id="submit" onclick="init();">Submit</button>
                <h3 id="infoStart">Please select a start position.</h3>
                <br />
                <h3 id="infoEnd">Please select an end position.</h3>
                <br />
                <div id="theRest">
                    <h3>Please select algorithm.</h3>
                    <select id="algorithm" onchange="handleChange();">
                        <option default selected>A Star</option>
                        <option>Dijkstra</option>
                        <option>Best First</option>
                        <option>Custom</option>
                    </select>
                    <h3>Please select heuristic.</h3>
                    <select id="heuristic">
                        <option default selected>Manhattan</option>
                        <option>Euclidean</option>
                        <option>Diagonal</option>
                    </select>
                    <h3 id="speed">Speed</h3>
                    <input id="slider" type="range"  max="3000" value="500">
                    <br />
                    <button id="gameify" onclick="setGameify();">GAMEIFY!</button>
                    <br />
                    <br />
                    <button id="go" onclick="beginpaths();">GO!</button>
                </div>
                <div id="results">
                    <h4>Final # of Steps</h4>
                    <p id="numSteps"></p>
                    <h4>Final Length</h4>
                    <p id="finalLength"></h4>
                </div>
                <div id="buttons">
                    <br />
                    <!--<button id="stepBack" onclick="stepBackward();">&lt&lt Step</button>-->
                    <button id="playAndPause" onclick="setPlay();">Pause</button>
                    <button id="stepForward" onclick="stepForward();">Step &gt&gt</button>
                </div>
            </div>
        </div>
        <img id="floor" src="floor.png"></img>
        <img id="tile" src="tile.png"></img>
        <img id="player" src="player2.png"></img>
        <img id="princess" src="princess.png"></img>
    </body>
</html>